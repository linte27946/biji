# 算法

## 二叉树

### 创建

使用递归的方式创建二叉树（自定义）

```c++
struct Bi_Node
{
    char element;
    struct Bi_Node *lchild;
    struct Bi_Node *rchild;
    // 构造函数
    Bi_Node(char data)
    {
        element = data;
        lchild = NULL;
        rchild = NULL;
    }
};
Bi_Node *insert()
{
    char elm;
    std::cin >> elm;
    if (elm == '#')
    {
        return nullptr;
    }
    Bi_Node *root = new Bi_Node(elm);
    root->lchild = insert();		//若要使用中序后序只需要改变这里的顺序就行了
    root->rchild = insert();
    return root;
}
```

举例如下：

构建如下的二叉树需要按照前序方式输入A B D # G # # # C E # # F # #

![](/media/kobayashi/新加卷/myblog/typora-user-images/数据结构和算法/binary_tree.png)

完全二叉树：

1、数组的实现方法

对于完全二叉树，按顺序1~n编号，若父节点为i；则左孩子为2i，右孩子为2i+1；若树深度为k，则前k-1为满二叉树；因此判定当2\*i<=n时,建立左子树，当2*i+1<=n时，建立右子树。

如果之后要对其进行扩展或者插入元素，可以使用vector动态数组。

```c++
int visit(int i)
{
	cout << i << endl;	    //若要使用中序后序只需要改变这里的顺序就行了
    if(2*i<=数组小大小)
    visit(2*i);	
	if(2*i+1<=数组大小)
    visit(2*i+1);
}
```

优点：实现简单，好理解。

2、链式实现方法

## 红黑树

红黑树（R-B TREE，全称：Red-Black Tree），本身是一棵二叉查找树，在其基础上附加了两个要求：

1、树中的每个结点增加了一个用于存储颜色的标志域；

2、树中没有一条路径比其他任何路径长出两倍，整棵树要接近于“平衡”的状态。

**特征：**

- 根节点是黑色的
- 如果该节点是红色的则其子节点全部都是黑色的
- 对于每个节点，从该节点到其所有子节点的路径上的黑节点个数都相同

### 插入

首先根节点为黑，之后每次插入的节点都为红。

1、如果父节点为黑则直接插入

2、如果父叔都为红则进行颜色对调，即(父叔)<--->(爷)

3、如果父红叔黑，则进行旋转





## 图论：

### Floyd - Warshall（弗洛伊德算法）

- n*n为图的大小，G[i] [j]为图中每项的权重
- 求任意两点之间的距离，是多源最短路
- 属于动态规划思想
- 时间复杂度

```c++
核心算法：
for(int k = 0; k < n; ++k) {
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			G[i][j] = min(G[i][j],G[i][k] + G[k][j]);
		}
	}
}
```

### Dijkstra (迪杰斯特拉算法)

- 用于计算一个节点到其他节点的最短路径
- 属于贪心思想
- 时间复杂度O(n^2)

```c++
//最短路径 - Dijkstra算法 参数：图G、源点v
void Dijkstra(Graph G, int v)
{
	//初始化
	int n = G.vexnum;//n为图的顶点个数
	for (int i = 0; i < n; i++)
	{
		S[i] = false;
		D[i] = G.Edge[v][i];
		if (D[i] < INF)Pr[i] = v; //v与i连接，v为前驱
		else Pr[i] = -1;
	}
	S[v] = true;
	D[v] = 0;
	//初始化结束,求最短路径，并加入S集
	for (int i = 1; i < n; i++)
	{
		int min = INF;
		int temp;
		for (int w = 0; w < n; w++)
			if (!S[w] && D[w] < min) //某点temp未加入s集，且为当前最短路径
			{
				temp = w;
				min = D[w];
			}
		S[temp] = true;
	//更新从源点出发至其余点的最短路径 通过temp
		for (int w = 0; w < n; w++)
			if (!S[w] && D[temp] + G.Edge[temp][w] < D[w])
			{
				D[w] = D[temp] + G.Edge[temp][w];
				Pr[w] = temp;
			}
	}
}
```

## 排序

### 堆排序

概念：满足以下关系的称为堆

- ki ≤ k2i 且 ki ≤ k2i+1（在 n 个记录的范围内，第 i 个关键字的值小于第 2\*i 个关键字，同时也小于第 2*i+1 个关键字）
- ki ≥ k2i 且 ki ≥ k2i+1（在 n 个记录的范围内，第 i 个关键字的值大于第 2\*i 个关键字，同时也大于第 2*i+1 个关键字）

简单来说就是子节点的值都比根节点大/小的完全二叉树

{49，38，65，97，76，13，27，49}	将该表构建堆如下：

​	

![](./typora-user-images/数据结构和算法/heap.png)

堆排序思路：

通过将无序表转化为堆，可以直接找到表中最大值或者最小值，然后将其提取出来，令剩余的记录再重建一个堆，取出次大值或者次小值，如此反复执行就可以得到一个有序序列，此过程为堆排序。

步骤：

一、sort函数：将根节点与叶子结点进行比较，将他们之间最小的值与根节点进行交换

二、对每个根节点进行sort操作，最后顶部的值就是我们想要的最小值

三、拿掉最小值，重复进行第一、二步操作。

### 快排

思路：

一、使用两个指针分别指向数组的头和尾，并令头部位分隔值T，将大于该值的都放到其右边，小于其的都放到左边

二、先由尾指针从右往左依次遍历，直到找到一个比 T小的关键字，找到之后将该关键字同头指针的值进行互换

三、然后头指针从左往右依次遍历，直到找到一个比 T 大的关键字为止，同样找到后同尾指针的值进行互换

四、反复进行二、三 两步操作直到两指针指向同一个值。

五、以第四步指向的值为分界点，对左边和右边分别进行如上操作（递归）

举例如下：

......................................................................................................

**49**，38，65，97，76，13，27，**49**									

**49**，38，65，97，76，13，**27**，49

**27**，38，65，97，76，13，**49**，49			//交换

27，**38**，65，97，76，13，**49**，49	 	

27，38，**65**，97，76，13，**49**，49

27，38，**49**，97，76，13，**65**，49			//交换

27，38，**49**，97，76，**13**，65，49

27，38，**13**，97，76，**49**，65，49

27，38，13，**97**，76，**49**，65，49

27，38，13，**49**，76，**97**，65，49			//交换

27，38，13，**49**，**76**，97，65，49

27，38，13，**49**，76，97，65，49

...对上述进行递归

.........................................................................................................

### 归并排序

![](./typora-user-images/数据结构和算法/1051596232-0.png)

思路：

一、先对数组进行递归的拆解得到小数组

二、对数组进行两两合并，最终还原出排列完整的数组

合并过程：

新建两个数组，将要归并的两个数组赋值过去，然后将这两个数组进行比较将较小的值放回原数组，这样反复进行，最终就可以得到一个有序的子数组。

## boyer-moore算法

boyer-moore算法最简单理解方法： 假设你在投票选人  如果你和候选人（利益）相同，你就会给他投一票（count+1），如果不同，你就会踩他一下（count-1）当候选人票数为0（count=0）时，就换一个候选人，但因为和你利益一样的人占比超过了一半 不论换多少次 ，最后留下来的都一定是个和你（利益）相同的人。

## Floyd 判圈算法

如果链表无环，指针在前进时能检测到其 next 为空，程序结束。我们重点分析有环的情况。

设线上有若干个节点。红指针为 fast，蓝指针为 slow。从头节点同时前进，fast 每次前进两个节点，slow 每次前进一个节点。那么如果存在圈则他们一定会相遇。

## DFS（深度优先搜索算法）

链接：https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/

二叉树的DFS

可以看到，二叉树的 DFS 有两个要素：「访问相邻结点」和「判断 base case」。

第一个要素是访问相邻结点。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。

第二个要素是 判断 base case。一般来说，二叉树遍历的 base case 是 root == null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 root == null 的时候及时返回，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。

```c++
void traverse(TreeNode root) {
    // 判断 base case
    if (root == null) {
        return;
    }
    // 访问两个相邻结点：左子结点、右子结点
    traverse(root.left);
    traverse(root.right);
}
```

网格类问题的 DFS 

对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：

首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，网格结构是「四叉」的。

在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了

```c++
void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    if (!inArea(grid, r, c)) {
        return;
    }
    // 如果这个格子不是岛屿，直接返回
    if (grid[r][c] != 1) {
        return;
    }
    grid[r][c] = 2; // 将格子标记为「已遍历过」
    
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
bool inArea(int[][] grid, int r, int c) {
    int n = grid.size();
    int m = grid[0].size();
    if (r > n - 1 || c > m - 1 || r < 0 || c < 0)
        return false;
    else
        return true;
}
```

