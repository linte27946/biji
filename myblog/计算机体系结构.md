# 计算机体系结构

## 一、计算机体系结构的基本概念

### 重点内容

1.计算机系统的层次结构
2.计算机体系结构的定义及研究内容
3.计算机系统的评价方法
4.冯·诺依曼结构及其发展
5.透明性、系列机、兼容性等概念
6.了解计算机系统的分类方法

### 1.1计算机体系结构的概念

**定义：** 计算机系统结构，也称计算机体系结构

- 经典定义：计算机系统结构是程序员所看到的计算机属性，即概念性结构与功能特性
- 广义定义：计算机系统结构囊括计算机设计的3个方面：指令集结构、组成、硬件

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/image-20240424161132865.png" alt="image-20240424161132865" style="zoom:80%;" />

**计算机系统结构、计算机组成、计算机实现三者之间的区别和联系**
区别

    计算机系统结构的实质是一种系统设计，就是完成硬件、软件的功能分配, 对计算机的机器级界面的确定。界面之上，是软件实现的功能；界面之下是硬件和固件实现的功能。
    
    计算机组成的实质是一种逻辑设计，是计算机系统结构的逻辑实现（数据流、控制流、控制机构、各部件的功能及连接）
    
    计算机实现的实质是一种物理设计，是计算机组成的具体物理实现（器件、组装）

联系

    相同系统结构的计算机可以采用不同的组成；相同组成的计算机可以采用不同的实现技术
    
    组成设计向上决定于结构，向下受限于实现技术
**分类：**

- **冯氏分类法**： 用系统的最大并行度对计算机进行分类

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/1.png" style="zoom:80%;" />

- **Flynn分类法：**按照指令流和数据流的多倍性进行分类
  - 单指令流单数据流 SISD. 传统的顺序处理计算机
  - 单指令流多数据流 SIMD. 阵列处理机、向量处理机等
  - 多指令流单数据流 MISD. 只是一种人为划分，目前没有实际的计算机
  - 多指令流多数据流 MIMD. 多处理机等

ps：相关概念定义

- 指令流：计算机执行的指令序列
- 数据流：由指令流调用的数据序列
- 多倍性：在系统受限的部件上，同时处于同一执行阶段的指令或数据的最大数目

### 1.2 定量分析技术

计算机系统设计的定量原理：

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/2.png" alt="image-20240424165406267" style="zoom:80%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/3.png" style="zoom:80%;" />  

如果仅仅对计算任务中的一部分做性能改进，则改进得越多，所得到的总体性能的提升就越有限，当部件加速比为无穷时，加速比不超过1/(1-可改进比例)

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/4.png" style="zoom: 80%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/5.png" style="zoom: 80%;" />   

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/6.png) 

### 1.3 计算机体系结构的发展

**冯诺依曼结构**

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/7.png) 



### 1.4 计算机体系结构中并行性的发展

**计算机系统中的并行性有不同的等级：**

从处理数据的角度看，并行性等级从低到高可分为：

(1)字串位串：同时只对一个字的一位进行处理。这是最基本的串处理方式，不存在并行性。

(2)字串位并：同时对一个字的全部位进行处理，不同字之间是串行的。这里已开始出现并行性。

(3)字并位串：同时对许多字的一位进行处理。这种方式有较高的并行性。

(4)全并行：同时对许多字的全部位进行处理。这是最高一级的并行性。

从执行程序的角度看，并行性等级从低到高可分为：

(1)指令内部并行：一条指令执行时各微操作之间并行。

(2)指令级并行：并行执行两条或多条指令。

(3)任务级或过程级并行：并行执行两个以上过程或任务（程序段）。

(4)作业或程序级并行：并行执行两个以上作业或程序。

## 二、计算机指令集结构

### 重点内容

### 2.1指令集结构的分类

指令集体系结构分为三种类型
➢ 堆栈结构
➢ 累加器结构
➢ 通用寄存器结构（根据操作数的来源不同又可分为）

- 寄存器-存储器结构（RM结构）：操作数可以来自存储器
- 寄存器-寄存器结构（RR结构）：所有操作数均来自通用寄存器组

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/8.png" style="zoom:67%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/9.png" style="zoom: 67%;" />  

通用寄存器型指令集体系结构进一步细分为3种类型：
➢ 寄存器-寄存器型（RR型）
➢ 寄存器-存储器型（RM型）
➢ 存储器-存储器型（MM型）

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/10.png" alt="截图 2024-04-24 21-34-44" style="zoom: 80%;" />

### 2.2寻址方式 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/11.png" style="zoom:80%;" /> 

### 2.3指令集结构的功能设计

**从当前的计算机技术观点来看，CISC结构有什么缺点？**

（1）各种指令的使用频度相差悬殊，许多指令很少用
（2）指令系统庞大，指令条数多许多指令的功能又很复杂
（3）许多指令由于操作繁杂，其CPI值比较大，执行速度慢。采用这些复杂指令可能使整个程序的执行时间反而增加。
（4）由于指令功能复杂，规整性不好，不利于采用流水技术来提高性能
**简述RISC结构的设计原则。**

（1）指令条数很少、指令功能简单。只选取使用频度很高的指令，在此基础上补充一些最有用的指令
（2）采用简单而又统一的指令格式，并减少寻址方式；指令字长都为32或64位
（3）指令的执行在单个机器周期内完成
（4）只有load和store指令才能访问存储器，其他指令的操作都是在寄存器之间进行
（5）大多数指令都采用硬连逻辑来实现

### 2.4指令格式的设计和优化

- **哈夫曼编码：**简单直观但变长度、不规整不利于硬件处理

- **扩展操作码：** 位于定长二进制编码和哈夫曼编码之间的一种编码方案。采用有限几种固定长度的码长，仍然采用高概率的用短码、低概率用长码的哈夫曼压缩思想，使操作码平均长度缩短。

  ![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/12.png) 

表格中的是2-4扩展操作码

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/13.png" alt="image-20240425143949123" style="zoom:80%;" /> 

hafuman平均码长为：0.4 \* 1 + 0.3 * 2 + 0.15 \* 3+ ( 0.05 + 0.04 + 0.03 + 0.03 ) \* 5 = 2.2

2-4平均码长为：( 0.4 + 0.3 + 0.15) * 2 + ( 0.05 + 0.04 + 0.03 + 0.03 ) * 4 = 2.3

- **等长扩展码**

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/14.png)  

**指令集的3种编码格式**
➢ 变长编码格式、定长编码格式、混合型编码格式

- **定长编码**

1、所有指令的操作码都是同一的长度
2、保证操作码的译码速度、减少译码的复杂度
3、以程序的存储空间为代价来换取硬件实现上的好处

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/15.png) 

- **变长编码**

➢ 当指令集的寻址方式和操作种类很多时，这种编码格
式是最好的。（VAX, X86）

优点：用最少的二进制位来表示目标代码
缺点：可能会使各条指令的字长和执行时间相差很大

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/17.png) 

- **混合型编码**、

➢ 提供若干种固定的指令字长
➢ 以期达到既能够减少目标代码长度，又能降低译码复杂度的目标

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/16.png) 

### 2.5MIPS指令集体系结构

## 三、流水线技术


### 3.1流水线的基本概念

**流水线的分类：**

1、部件级流水线、处理机级流水线、系统级流水线

2、单功能流水线、多功能流水线

3、静态流水线、动态流水线

4、线性流水线、非线性流水线

5、顺序流水线、乱序流水线

### 3.2流水线的性能指标

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/20.png" style="zoom:80%;" /> 

**一道例题:**

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/18.jpg" style="zoom:80%;" /> 



<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/19.jpg" style="zoom:80%;" /> 

**流水线设计中的若干问题**

**1、瓶颈问题**
 当流水线各段时间不等时，时间最长的那一段就成了瓶颈。

**消除瓶颈段的两种方法：**
 a）细分瓶颈段-把流水线中的瓶颈段切割成几段，使各段执行时间相等。

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/21.png) 

b）重复设置瓶颈段-重复设置的段并行处理，在时间上依次错开工作

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/22.png) 

**2、额外开销**
锁存器的延迟
时钟偏移开销-流水线中的时钟到达各锁存器的最大插值时间
采用流水线技术后，虽然可以提高指令的吞吐率，从而提高程序的执行速度，但流水线并不能真正减少单条指令的执行时间。事实上，由于额外开销的存在，单条指令的执行时间反而会增加。
**3、冲突问题**
流水线的指令之间存在相关性，可能要相互等待，从而导致停顿。
**例题：**

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/23.jpg" alt="4faa00a000c8a55928c27377b9f6699" style="zoom: 67%;" />  

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/24_1.jpg) 

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/24.jpg) 

**性能指标的几个问题**
1、流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率

2、增加流水线的深度（段数）可以提高流水线的性能

3、流水线的深度受限于流水线的额外开销
当时钟周期小到与额外开销相同时，流水已没意义。因为这时在每一个时钟周期中已没有时间来做有用的工作

### 3.3 流水线的相关与冲突

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/23.png) 

**相关**

**1、数据相关**

指令j需要用到指令i产生的结果

指令j与指令i数据相关，而i又和k数据相关（传递性）

**2、名相关**

两条指令使用了相同的寄存器或存储单元的名字，但它们之间并没有数据流动。

**3、控制相关**
 控制相关是指由分支指令引起的相关，它需要根据分支指令的执行结果来确定后面该执行哪个分支上的指令。

**流水线冲突**

**1、结构冲突**

在同一时间访问同一个存储器

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/24.png" style="zoom:80%;" /> 

为了消除这种冲突，可以在前一条指令访问存储器时，将流水线停顿一个时钟周期，该停顿周期往往被称为“气泡”。

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/25.png" style="zoom:80%;" /> 

或者采用分别设置独立的指令存储器和数据存储器的方法。或者一个存储器，但是采用两个分离的Cache：指令Cache、数据Cache。

**2、数据冲突**

当指令在流水线中重叠执行时，因需要用到前面指令的结果而发生的冲突。

a. 写后读冲突（Read After Write, RAW）

b. 写后写冲突（Wirte After Write, WAW）

c. 读后写冲突（Read After Write, RAW）：

**可以使用定向技术减少数据冲突引起的停顿。**
对于前面例子中的数据冲突，简单的处理方法是暂停流水线中DADD之后的所有指令，直到DADD指令将计算结果写入寄存器R1之后，再让DADD之后的指令继续执行，但这种暂停会导致性能下降。
<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/26.png" style="zoom:80%;" /> 

但是定向技术只能向同一时间或者之后传递数据，也就是箭头只能指向同一时间或之后。

当向之前就需要该数据传递值时，我们就要进行延迟流水线。

但如果我就是不想延迟流水线，这时候可以求助于万能的编译器

**编译器解决数据冲突**

延迟是不可避免的，但是编译器可以在这个延迟中执行其它不相关的指令，来充分利用这个空隙

考虑A=B+C

| LD RB,B       | IF   | ID   | EX   | MEM  | WB    |      |      |      |      |
| ------------- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- |
| LD RC,C       |      | IF   | ID   | EX   | MEM   | WB   |      |      |      |
| DADD Ra,Rb,Rc |      |      | IF   | ID   | stall | EX   | MEM  | WB   |      |
| SD Ra,A       |      |      |      | IF   | ID    |stall | EX   | MEM  | WB |      |

现在考虑生成 A=B+C 和 D=E-F

​       调度前的代码                                  调度后的代码

![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/27.png)                 ![](/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/28.png)

**3、控制冲突**

流水线遇到分支指令或其它会改变PC值的指令所引起的冲突。

在流水线中，控制冲突可能会比数据冲突造成更多的性能损失，所以同样需要得到很好的处理。

- **预测分支失败**

方法是沿失败的分支继续处理指令，当确定分支失败时，就将分支指令看成一条普通指令，正常流动；当确定分支成功时，就把分支之后取出的指令转换为空操作，并按分支目标地址重新取指令执行。

保证分支结果出来之前不能改变处理机的状态，以便于猜错后处理机能够回到原先的状态

- **预测分支成功**

当流水线检测到分支指令后，一旦计算出了分支目标地址，就开始从该目标地址取指令执行。

- ##### 延迟槽

在分支指令后加1~n个延迟

具体延迟槽里放的指令是由编译器来选择的。实际上，延迟槽能否带来好处完全取决于编译器能否把有用的指令调度到延迟槽中，这也是一种指令调度技术。常用的调度方法有三种：从前调度、从目标处调度、从失败处调度。

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/29.png" style="zoom:80%;" /> 

a) 从前调度
把位于分支指令之前的一条独立的指令移到延迟槽。
b）从目标处调度
如图，分支指令之前数据存到了R1寄存器，然后R1寄存器被用于了分支指令的判断，所以不能把分支指令之前的这条指令调到延迟槽。
但是可以将分支指令跳转地址的第一条指令调到延迟槽，然后把分支跳转地址修改为第一条指令所在地址的后面，这实际上是预测了分支会成功，如果失败，相当于延迟槽中的指令就无用了。而且这要求分支地址计算在下一条指令进入之前完成。
c）从失败处调度
即将分支指令后面的第一条指令放入延迟槽，正常运行。

### 3.4向量处理机

## 四、指令级并行

### 4.1指令级并行的概念

**1、指令级并行**：指指令之间存在的一种并行性，利用它，计算机可以并行执行两条或两条以上的指令。

**2、理想CPI是衡量流水线最高性能的一个指标**
**流水线处理机的实际CPI = 理想流水线的CPI + 各类停顿的时钟周期数**
CPI流水线 = CPI理想 + 停顿结构冲突+ 停顿数据冲突 + 停顿控制冲突

**3、循环级并行**

程序平均每4～7条指令就会有一个分支

- 由于数据相关，基本块内的并行性非常有限
-  比基本块的平均大小要小的多

为了提高指令级并行，使一个循环中的不同循环体并行执行，是最常见、最基本的方法，也是指令级并行研究的重点之一

| 产生结果指令       | 使用结果指令       | 延迟时钟数 |
| ------------------ | ------------------ | ---------- |
| 浮点计算           | 另外的浮点计算     | 3          |
| 浮点计算           | 浮点数据存操作(SD) | 2          |
| 浮点数据取操作(LD) | 浮点计算           | 1          |
| 浮点数据取操作(LD) | 浮点数据存操作(SD) | 0          |

```c++
//c语言循环程序
for (i = 1; i <= 1000; i++) {
    x[i] = x[i] + s;
}
```

```asm
;对应的汇编代码：
Loop:   LD      F0,0(R1) ;F0为向量元素
        ADDD    F4,F0,F2 ; F0+F2->F4
        SD      0(R1),F4 ;存储结果到F4  
        SUBI    R1,R1,#-8 ;修改指针
        BNEZ    R1,Loop   ;循环控制
```

```asm
;无调度实际的执行：
Loop:   LD      F0,0(R1) ;F0为向量元素
		stall			 ;停1拍
        ADDD    F4,F0,F2 ; F0+F2->F4
        stall
        stall			 ;停2拍
        SD      0(R1),F4 ;存储结果到F4  
        SUBI    R1,R1,#-8 ;修改指针
        stall				 ;停1拍
        BNEZ    R1,Loop   ;循环控制
        stall			  ;延迟槽
```

**静态调度**

静态调度是指通过改变指令顺序而不改变指令间数据相关来改善指令延迟，把上述R1的递减改到前面并利用**延迟槽技术**（设置延迟槽为1）可以让上述基本快代码压缩到6个周期完成：

```assembly
Loop:  LD      F0,0(R1)
       DADDI   R1,R1,#-8
       ADDD    F4,F0,F2
       <stall>
       BNEZ    R1,Loop
       SD      8(R1),F4
```

加速比：10 / 6 = 1.7

3个有效时钟节拍（L.D，ADD.D，S.D）

- 节拍有效比率占50%
- 1拍空转占17%
- 2拍循环控制占33%

**循环展开**：循环展开3次得到4个循环体

```asm
Loop:  LD      F0,0(R1)			1
       ADDD    F4,F0,F2			2,3			;等待
       SD      0(R1),F4			4,5,6
       
       LD      F6,0(R1)			7
       ADDD    F8,F6,F2			8,9
       SD      -8(R1),F8		10,11,12	
       
       LD      F10,-16(R1)		13
       ADDD    F12,F10,F2		14,15
       SD      -16(R1),F12		16,17,18
       
       LD      F14,-24(R1)		19
       ADDD    F16,F14,F2		20,21
       SD      -24(R1),F16		22,23,24
       
       DADDI   R1,R1,#-32		25
       BNEZ    R1,R2,Loop		26,27
       
       stall					28
```

循环使用28个时钟节拍

14个空转节拍

- 每个L.D有1个空
- 每个ADDD有2个空
- DADDUI有1空
- BRANCH有1空

14个指令流出节拍

每遍循环7个时钟节拍，共使用9个寄存器

**循环+指令调度**

```asm
Loop:  LD      F0,0(R1)
       LD      F6,-8(R1)
       LD      F10,-16(R1)
       LD      F14,-24(R1)
       ADDD    F4,F0,F2
       ADDD    F8,F6,F2
       ADDD    F12,F10,F2
       ADDD    F16,F14,F2
       SD      0(R1),F4
       SD      -8(R1),F8
       DADDI   R1,R1,#-32
       SD      16(R1),F12
       BNEZ    R1,Loop
       SD      8(R1),F16
```

使用14个节拍，每个元素使用3.5个节拍

### 4.2 指令的动态调度

**动态调度与静态调度的区别**
静态调度是在编译阶段（代码执行前）利用编译器对代码进行调度。如第三章的流水线。如果存在数据冲突且 无法通过重定等方法解决，只能停顿。
动态调度是在程序执行阶段利用硬件进行调度。同时还能保证数据流和异常行为。

**动态调度的优点**
1.能够处理情况不明的相关（编译器无法检测出）。
2.一条指令的不同阶段可以在不同流水线中完成。

**缺点是硬件的复杂度显著增加**

**1、记分牌技术**

流水线ID段被分为两级

- 流出-->解析指令，检查结构相关
- 读操作数-->直到不存在数据相关时，才读取操作数
- 如果存在WAR或者WAW相关，记分牌会暂停这条指令的执行，直到相关消除后才继续执行

记分牌允许指令乱序执行，前提

- 充足的资源，无数据相关
- 记分牌动态解决了先写后读相关

- 指令可以乱序执行

 基本原理

- 每条指令均经过记分牌，记录各指令间数据相关的信息如果记分牌判断出一条指令不能立即执行，它就检测硬件的变化从面决定何时能够执行

**2、Tomasulo算法**

**核心思想：**

记录和检测指令间的相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能性减少到最小；
通过寄存器换名来消除WAR冲突和WAW冲突

**例题：**

```asm
L.D		F6, 34（R2）
L.D		F2, 45（R3）
MUL.D	F0, F2, F4
SUB.D	F8, F2, F6
DIV.D	F10, F0, F6
ADD.D	F6, F8, F2
```

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/30.jpg" style="zoom: 33%;" /> <img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/31.jpg" style="zoom: 33%;" />

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/32.jpg" style="zoom: 33%;" /> <img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/33.jpg" style="zoom: 33%;" />

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/34.jpg" style="zoom: 33%;" /> <img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/35.jpg" style="zoom: 33%;" />

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/36.jpg" style="zoom: 33%;" /> <img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/37.jpg" style="zoom: 33%;" />

后续略。。。

**Tomasulo算法具有两个主要的优点：**

- 冲突检测逻辑是分布的（通过保留站和CDB实现）
  如果有多条指令已经获得了一个操作数，并同时在等待同一运算结果，那么这个结果一产生，就可以通过CDB同时播送给所有这些指令，使它们
  可以同时执行。
- 消除了WAW冲突和WAR冲突导致的停顿
  使用保留站进行寄存器换名，并且操作数一旦就绪就将之放入保留站。

**缺点：**

高复杂性，需要大量的硬件
存在瓶颈：单个公共数据总线引发竞争


### 4.3动态分支预测技术

**分支预测缓冲**

采用存储阵列存储最近一次分支知否成功

如图是2位分支预测缓冲

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/38.png" style="zoom: 67%;" /> 

**分支目标缓冲器BTB**

目的：取分支指令的时候就知道下调指令在哪

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/39.png" style="zoom:67%;" /> 

**基于硬件的前瞻执行**

前瞻执行的基本思想：

- 对分支指令的结果进行猜测，并假设这个猜测总是对的，然后按这个猜测结果继续取、流出和执行后续的
  指令。
- 只是执行指令的结果不是写回到寄存器或存储器，而是放到ROB（ReOrder Buffer）的缓冲器中。
- 等到相应的指令得到“确认”（commit）（即确实是应该执行的）之后，才将结果写入寄存器或存储器。

### 4.4多指令流出技术

**超标量**

支持每个时钟周期发出1-8条不相关的指令，如果指令流中的指令相关或者不满足限制条件，则只能流出前面的指令。
可以通过编译器进行静态调度，也可以基于Tomasulo算法进行动态调度

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/40.png" style="zoom:50%;" /> 

Loop:   LD     	 F0,0(R1)		 ;F0为向量元素
       	 ADDD    F4,F0,F2 	; F0+F2->F4
        	SD      	0(R1),F4 		;存储结果到F4  
        	SUBI      R1,R1,#-8 	;修改指针
        	BNEZ     R1,Loop   	;循环控制

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/41.jpg" style="zoom:50%;" /> 

每次循环需12个时钟周期
每个迭代时2.4个时钟周期
前面在普通的流水线上，通过循环展和调度，可以达到每个迭代为3.5个时钟周期
超标量可以获得更好地性能，代价是硬件复杂性大幅度增加

**超长指令字**



例题：

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/45.jpg" style="zoom: 67%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/46.jpg" style="zoom: 67%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/47.jpg" style="zoom:67%;" /> 

## 五、存储系统

### 5.1存储系统的层次结构

看书略。

### 5.2Cache基本知识

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/42.jpg" style="zoom:50%;" />  

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/43.jpg" style="zoom:50%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/44.jpg" style="zoom:50%;" /> 

一、对于采用直写法+写分配法
1.若读命中，则访问主存0次
2.若读不命中，需要将主存中的数读入cache，调入一整块数据，若每个cache块为2个字，而主存每次只能读或写一个字，那么需要访存两次。
3.若写命中，则需要将数据立即写入主存，访存一次。
4.若写不命中，则需要先访问主存写一个字，然后将整块调入cache，需要访存3次
二、对于采用回写法+写分配法
若采用回写法，则不需要分那么清楚，只需要考虑命中还是不命中，如果是命中，则不用访问主存(读、写都一样)，如果是不命中，需要调入块，要考虑要替换的块是否是脏块。
1.若是不命中且不是脏块，需要访存2次，将整块的数据调入cache。
1.若是不命中且是脏块，需要访存4次，将整块的数据调入cache的同时，还得将旧块调回主存。
<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/48.png" style="zoom: 67%;" />  

 <img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/49.png" style="zoom: 67%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/50.png" style="zoom: 67%;" /> 

**比较不同替换算法**

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/51.png" style="zoom: 50%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/52.png" alt="截图 2024-04-27 16-48-03" style="zoom: 50%;" /> 



<img src="/media/kobayashi/新加卷/myblog/typora-user-images/计算机体系结构/53.png" style="zoom: 50%;" /> 


### 5.3降低Cache失效率

**强制性失效 (Compulsory miss)**
 当第一次访问一个块时，该块不在Cache中，需从下一级存储器中调入Cache。(冷启动失效，首次访问失效)
**容量失效 (Capacity miss )**
如果程序执行时所需的块不能全部调入Cache中，则当某些块被替换后，若又重新被访问，就会发生失效。
**冲突失效 (Conflict miss)**
在组相联或直接映像Cache中，若太多的块映像到同一组(块)中，则会出现该组中某个块被别的块替换，然后又被重新访问的情况。(碰撞失效，干扰失效)

**比较不同大小的cache**

假设对指令Cache的访问占全部访问的75%；而对数据Cache的访问占全部访问的25%。Cache的命中时间为1个时间周期，失效开销为50个时间周期，在混合Cache中一次load或store操作访问Cache的命中时间都要增加一个时间周期，32KB的指令Cache的失效率为0.39%，32KB的数据Cache的失效率为4.82%，64KB混合Cache的失效率为1.35%。试问指令Cache和数据Cache容量均为32KB的分离Cache和容量为64KB的混合Cache相比，哪种Cache的失效率更低？两种情况下平均访存时间各是多少？ 

    解：（1).根据题意：75%的访存为取指令，因此分离Cache总体失效率为
    
                         75% x 0.39%+25% x4.82%=1.50%
    
                    而64KB混合Cache的不命中率为1.35%，所以混合Cache的失效率比分离Cache的低一些。
    
           （2）平均访问时间=命中时间+不命中率 x 不命中开销
    
                  分离Cache的平均访问时间=75% x (1+0.39% x 50)+25% x(1+4.82% x 50）=1.749
    
                 混合Cache的平均访问时间=75% x (1+1.35% x 50) + 25% x(1+1+1.35% x 50）=1.925

### 5.4减少Cache失效开销

### 5.5减少命中时间





