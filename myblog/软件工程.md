# 软件工程

## 第一章、需求与可行性分析

### 一、需求的含义、分类和重要性

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/11.png" style="zoom: 80%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/12.png" style="zoom: 67%;" />  

### 二、软件需求的特征

**什么是需求分析**

确定你要开发的系统所必须具有的功能和性能,系统要求的运行环境,并且预测系统发展的前景等一系列分析

 <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/13.png" style="zoom: 67%;" />

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/14.png" style="zoom: 67%;" /> 

### 三、用况模型以及用况模型的建立方法:star:

#### 1、基本概念

用例图包括：**参与者、用例、关系**和**边界**四个要素。

**参与者：**与系统交互的**用户**或其他**软硬件系统**，用**小人形**表示。

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/22.png" alt="image-20240506213100314" style="zoom:25%;" /> 

**用例：**系统中执行的一系列**动作**，用**椭圆**表示。

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/23.png" alt="image-20240506213334146" style="zoom:50%;" /> 

**关系：**参与者与用例、参与者之间、用例之间的联系。

**边界：**一组用例描述的系统或子系统，用**矩形框**表示。

#### 2、用例之间的关系

- 泛化关系

  - 扩展

    向一个用例中添加一些动作后构成了另一个用例，后者会继承前者的一些行为

    <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/24.png" alt="79b49f34a165a0090dbe937a641f49d" style="zoom:50%;" /> 

  - 使用

    一个用例使用另一个用例，一般来说如果在若干个

- <\<include>>

  一个用例（基础用例）的行为包含另外一个用例（被包含用例）的行为

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/25.png" style="zoom: 50%;" /> 

- <\<externd>>

  扩展用例可以在基础用例之上添加新的行为，**基础用例必须声明某些特定的扩展点，扩展用例只能在这些扩展点上扩展新的行为**，将扩展用例的事件流在一定的条件下按照相应的扩展点插入到基础用例中
  
  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/26.png" style="zoom:50%;" /> 

#### 3、例题

**酒店订房系统**

某酒店订房系统描述如下：

1. 顾客可以选择在线预订，也可以直接去酒店通过前台服务员预订；

2. 前台服务员可以利用系统直接在前台预订房间；

3. 不管采用哪种预订方式，都需要在预订时支付相应订金；

4. 前台预订首选通过现金形式进行订金支付，若现金不足，则只能通过信用卡形式进行订金支付，但是网上预订只能通过信用卡进行支付；

5. 利用信用卡进行支付时需要和信用卡系统进行通信；

6. 客房部经理可以随时查看客房预订情况和每日收款情况。

   <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/27.png" style="zoom:80%;" />  

   注：客房部经理指向的两个应该为房预订情况和每日收款情况

### 四、可行性分析的目的、意义

**目的不是研究如何解决问题，而是该问题是否值得去解决**

-  技术可行性 : 使用现有的技术能实现这个系统吗?
- 经济可行性：这个系统的经济效益能超过它的开发成本吗?
- 操作可行性：系统的操作方式在这个用户组织内行得通吗？
- 法律可行性：是否符合法律法规
- 外部环境可行性:系统运行的外部环境(计算环境、其它外部设备、系统环境等)是否能够支持该系统测试
- 其它:调度、社会效益等更广泛的方面研究每种解法的可行性

结果：不可行-----终止项目，可行------给出一个初步的可实施方案

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/7.png" style="zoom: 50%;" /> 


## 第二章、面向对象

### 一、面向对象方法的定义、基本原理

**定义**：面向对象是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构建系统软件开发的方法

**基本思想：**

- **从现实世界中客观存在的事物出发来构造系统**
  强调直接以问题域(现实世界)中的事物为中心来思考问题、认识问题，并根据这些事物的本质特征，把它们抽象为系统中的对象，作为系统的基本构成单位。这可以使系统直接映射问题域，保持问题域中事物及其相互关系的本来面貌。
- **充分运用人类日常的思维方法**
  强调运用人类在日常的逻辑思维中经常采用的思想方法与原则，例如抽象、分类、继承、聚合、封装、关联等等。这使得软件开发者能更有效地思考问题，并以其他人也能看得懂的方式把自己的认识表达出来。


### 二、类图建立方法:star:

- 类图建立的一般过程
- 识别类的方法、识别属性和操作的方法
- 识别继承、聚合、关联、消息的方法

#### 1、概念

**对象**：描述客观事物的实体，他是构成系统的基本单位

![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/15.png) 

**抽象与分类**：

忽略事物的非本质特征只注意那些与当前目标有关的本质特征，从而找出事物的共性，叫做抽象。抽象是形成概念的基本手段。把具有共同性质的事物划分为一类，叫做分类。

**类：**

具有相同属性和操作的一组对象的集合，他为属于该类的全部对象提供了统一的抽象描述。类的作用是用来创建对象，对象是类的一个实例。

**封装：**

把对象的属性和操作结合成一个独立的系统单位，并尽可能隐蔽对象的内部细节。

**封装的重要意义**

- 使对象能够集中而完整地描述并对应一个具体的事物。
- 体现了事物的相对独立性，使对象外部不能随意存取对象的内部数据，避免了外部 错误对它的“交叉感染”
- 对象的内部的修改对外部的影响很小，减少了修改引起的“波动效应”

**消息：**

消息是向对象发出的服务请求，目前在大部分面向对象的编程语言中，消息其实就是函数调用。

更一般的定义：消息是对象之间在一次交互传送的消息。

#### 2、**类与类之间的关系**

**关联：**

关联表示两个类的对象之间某种意义上的联系。关联有单向和双向

![](file:///home/kobayashi/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE%202024-04-23%2014-37-55.png) 

0..1表示 0到1个对象

0..* 或 \*表示0到多个对象

1+或者1.. *表示1到多个对象

1..15表示1到15个对象

3表示3个对象

![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/16.png) 

**聚集：(关联的特例)**

一个(较复杂的)对象由其他若干(较简单的)对象作为其构成部分，称作聚集。聚集刻画了现实事物之间的构成关系或者拥有关系

聚集关系又称为整体-部分关系，他是对象实例之间的一种关系。有时说两个类之间存在着整体-部分关系，是指一个类的对象实例以另一个类的对象实例作为组成部分。

- 共享聚集

  对象同时参与多个整体对象的构成，例如：一个课题组包含许多成员，每个成员又可以是另一个课题组的成员

  ps：菱心画在整体边上

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/17.jpg" style="zoom:80%;" /> 

- 组合聚集

  部分类完全隶属于整体类，部分与整体共存。

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/18.jpg" style="zoom: 50%;" /> 

**泛化关系（继承）**

特殊类拥有其一般类的全部属性与操作，称为特殊类对一般类的继承，继承意味着自动拥有、隐含地复制

![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/20.png) 

综合例子：一幅工程蓝图由许多图形组成,图形可以是直线、圆、多边形或组合图,而多边形由直线组成,组合图由各种线型混合而成。当客户要求画一幅蓝图时系统便通过蓝图与图形之间的关联(聚集)关系,由图形来完成画图工作,但是图形是抽象类,因此当涉及某种具体图形(如直线、圆等)时,便使用其相应子类中具体实现的draw功能完成绘图工作。

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/19.jpg" style="zoom:80%;" />  

**依赖和细化：**

两个模型，一个模型是独立的而另外一个模型依赖于独立的模型，如果独立的模型改变了，将影响依赖其的另一个模型

例如：一个类使用另一个类的对象作为他的数据成员。

对同一个实物在不同抽象层次上描述时，这些描述之间具有细化关系，

例如：A与B共同描述了一个实物，而A比B更加详细，则称B细化了A

使用虚线加空三角表示。

**例题：教务管理系统的类图**

(作业题，不确定是否正确)

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/21.png" style="zoom:80%;" /> 

### 三、UML和常见辅助模型的画法

#### 构件图

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/52.png"  />   

#### 活动图

![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/53.png) 

#### 状态机图

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/54.png" style="zoom:80%;" /> 

### 四、软件设计

**基本的设计原则是：高内聚，低耦合**

内聚性：模块内各个成分相互依赖的程度
耦合性：模块间相互依赖的程度

**耦合类型:(由强到弱)**

- 内容耦合:一个模块直接修改或操作另一个模块的数据。

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/56.png" style="zoom:50%;" />  

- 公共耦合:两个以上的模块共同引用一个全局的复杂数据项。

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/57.png" style="zoom:50%;" />  

- 外部耦合:两个模块共享一个全局的简单数据项。

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/58.png" style="zoom:50%;" /> 

- 控制耦合:一个模块向另一模块传递一个控制信号，接受信号的模块将依据该信号值进行必要的活动。

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/59.png" style="zoom:50%;" /> 

- 标记耦合:模块间共享复杂类型数据(可能使用不同的部分)

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/60.png" style="zoom:50%;" /> 

- 数据耦合:模块间通过参数传递基本类型的数据。

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/61.png" style="zoom:50%;" />  

**低耦合的基本原则：**如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，坚决避免使用内容耦合。

**内聚类型:(由低到高)**

- 偶然内聚:一个模块内各成分之间没有任何关系，
- 逻辑内聚:几个逻辑上相关的功能放在同一模块中。
- 时间内聚:一个模块完成的功能必须在同一时间内完成，而这些功能只是因为时间因素关联在一起。
- 过程内聚:处理成分必须以特定的次序执行
- 通信内聚:各成分都操作在同一数据集或生成同一数据集。
- 顺序内聚:各成分与一个功能相关，且一个成分的输出作为另一成分的输入。功能内聚:模块的所有成分对完成单一功能是最基本的，且该模块对完成这一功能而言是充分必要的。

 <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/55.png" style="zoom:80%;" /> 

## 第三章、结构化方法

1. 数据流图及其建模方法
2. 模块结构图，以及从数据流图到模块结构图的映射方法（变换设计+事务设计）
3. E-R模型及其建模方法
4. 状态机模型及其建模方法
5. 数据字典的定义和写法
6. 结构化分析的任务、结构化设计的任务
7. 关于软件分析/设计的目标、原则等内容（和面向对象方法基本重合）

### **一、系统流程图**

**就是描述物理系统的工具**

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/8.png" style="zoom:80%;" /> 

### **二、程序流程图**

**也就是程序框图，这个都学过。**

### **三、数据流图：**:star:

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/9.png" style="zoom:80%;" />  

例题：

某在线学习平台旨在提供一系列课程给学生进行学习。平台需支持学生注册、选课、观看课程视频、完成作业等功能。具体来说，该系统具有以下功能：

+ 学生注册：接收学生的注册信息，验证其有效性，并在学生数据库中创建新的记录。

+ 课程选择：展示课程列表给学生，接收学生的选课请求，并更新学生的选课记录。

+ 视频观看：提供课程视频给学生进行在线学习。

+ 作业提交：接收学生提交的作业数据，并进行存储。

请为该系统设计一个数据流图，并描述其中的过程和数据存储的功能。绘制包含至少两个层次的数据流图：顶层数据流图（0层图）和至少一个详细数据流图（1层或更多层图）。

错误纠正：这里面的1，2，3，4是数据处理，应该用圆角的框。

<img src="file:///home/kobayashi/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE%202024-04-22%2021-07-16.png" style="zoom:80%;" /> 

## 第四章、编码与实现

知识要点：

1、良好的编码风格有哪些

2、环形复杂度和路径复杂度的含义

### 一、基本原则

- **选择合适的编程语言**
- **良好的编码风格和习惯**
  - 变量、函数、类型命名合理、有意义
  - 总是检验输入/输出的合法性
  - 充分进行注释
  - 尽可能改进程序的效率
  - 使用简单的语句

- **注释**
  - 注释是提高代码可读性与可维护性的关键
  - 在每个模块(构件、类、方法)前，应当用注释说明该模块的功能、算法、接口特点和数据需求
  - 在关键的部分，注释和代码的比例至少应该是1:1
  - 注释应当具有规范的格式(开发小组内商定)
  - 必要时，注释应当包含日期或版本信息

- **检查输入输出的合法性**

  ```c++
  div(a,b)
  {
      return a/b;
  }
  div(a,b)
  {
  	if(b!=0) 
      	return a/b
      else throw ...
  }
  ```

- **效率改进**
  - 尽可能改进程序执行的效率(时间和空间复杂性)。
  - 在不破坏可读性与可维护性的情况下

- **影响效率的因素**
  - 不好的设计
  - 不好的算法选择和实现
  - 不恰当的数据结构
  - 类库的使用方式、网络通信、缓存机制等

### 二、代码/软件的质量

**定义：**

- **软件质量**
  - 对明确陈述的功能和非功能需求、明确记录的开发标准以及对所有专业化软件开发应具备的隐含特征的符合度
  - 需求是软件质量测量的基础
  - 标准定义了一组用以指导软件开发方式的准则
  - 不要忘记隐式的需求

**质量属性：**

- **功能性:**软件满足需求的程度
  - 准确性、互操作性、安全性等
- **可靠性**:软件可用的时间长度
  - 容错性、可恢复性等
- **易用性**:易于使用的程度
  - 易学性、可操作性等

- **效率:**资源使用的优化程度
- **可维护性:**软件易于修改的程度
  - 可理解性、可分析性、可修改性、可测试性等
- **可移植性:**软件移植到其它环境的容易程度
  - 适应性、可安装性、可替换性等

### 三、软件度量:star:

- **环形复杂度**：定量度量程序的逻辑复杂度。

  1、流图
  所谓流图实质上是“退化了的”程序流程图，它仅仅描绘程序的控制流程，完全不表现对数据的具体操作以及分支或循环的具体条件。
  （1）在流图中用圆表示结点，一个圆代表一条或多条语句
  （2）程序流程图中的一个顺序的处理框序列和一个菱形判断框，可以映射成流图中的一个结点
  （3）流图中的箭头称为边，它和程序流程图中的箭头线类似，代表控制流
  （4）流图中一条边必须终止于一个结点，即使这个结点并不代表任何语句（实际上相当于一个空语句）

  2、可以用下述三种方法中的任意一种来计算环形复杂度：
   （1）流图中的区域数等于环形复杂度
   （2）流图G的环形复杂度V(G)=E-N+2，其中，E是流图中边的条数，N是结点数。(推荐用这个简单方便):star:
   （3）流图G的环形复杂度V(G)=P+1，其中，P是流图中判定结点的数目

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/28.1.jpg" style="zoom: 50%;" />  

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/28.jpg" style="zoom: 33%;" /> 

  把程序流程图映射成流程图：（a）程序流程图（b）为流图
   如图（a）所示，流图中有九条边，八个结点，流图G的环形复杂度V(G)=E-N+2，
   所以V(G)=10-8+2=4 。

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/40.png" style="zoom: 80%;" /> 

  **当判断条件中出现了and或or时流图会不一样**

  需要逐个判断条件，所以会多出几个节点

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/31.png" style="zoom: 80%;" /> <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/32.PNG" style="zoom: 80%;" />

- **路径复杂度**

  源程序当中(通常是一个方法中)，完整独立的线性路径的数量

  **计算方法**:

  - 根据语句类型和条件数量而定
  - for、while:1+条件数量
  - if的数量+条件的数量+无条件的else的数量(默认1)

  举例：

   <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/33.png"  />

  ( ( 2 * 2 ) + 2 ) \* 2 \* 7 \* 3 = 252

## 第五章、形式化方法

虽然重要，但老师说不考:kissing_smiling_eyes:

## 第六章、测试:star:

1. 基本测试方法，黑盒、白盒测试的区别
2. 测试用例
3. 测试的策略与组织
4. 黑盒测试的技术：边界值分析、等价类测试、基于模型的测试
5. 白盒测试的技术：路径测试、数据流测试
6. 测试与调试的区别
7. 可靠性估计、bug估计方法

### 一、定义
**黑盒测试：**
黑盒测试又称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。

**白盒测试：**
白盒测试也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。

### 二、白盒测试

#### 路径测试

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/1.png" style="zoom: 67%;" /> 

程序流程图如下

 <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/2.png" style="zoom: 80%;" /> 

（x>3）&&（z<10）为真记为T1，为假记为F1

（x==4）||（y>5）为真记为T2，为假记为F2

【1】语句覆盖（设计若干个测试用例，使程序中的每个可执行语句至少执行一次

| 序号 | 状态 | x    | y    | z    | 路径 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | T1T2 | 4    | 5    | 6    | abd  |

【2】判定覆盖（设计足够多的测试用例，使程序中的每个判定都至少获得“真值”和“假值”）

| 序号 | 状态 | x    | y    | z    | 路径 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | T1F2 | 3    | 5    | 7    | abe  |
| 2    | F1T2 | 5    | 6    | 4    | acd  |

当然这里的状态也可以为T1T2和F1F2

【3】条件覆盖（每一个判定中每个逻辑条件的可能的值至少被满足一次）
（x>3）&&（z<10）

- （x>3）记为T1     （x<=3）记为F1

- （z<10）记为T2    （z>=10）记为F2

（x==4）||（y>5）

- （x==4）记为T3   （x不等于4）记为F3

- （y>5）记为T4      ( y<=5)记为F4


| 序号 | 状态     | x    | y    | z    | 路径 |
| ---- | -------- | ---- | ---- | ---- | ---- |
| 1    | T1T2T3T4 | 4    | 5    | 6    | abd  |
| 2    | F1F2F3F4 | 1    | 11   | 4    | ace  |

**条件覆盖与判定覆盖的区别在于，判定覆盖只关注于判定条件整体而条件覆盖则对每个逻辑都要进行真假判定**

【4】条件组合覆盖（每个判定中条件的各种可能组合都至少出现一次）即使路径不存在

```c
#include <stdio.h>
int calculate(int a, int b, int c) {
    int result = 0;
    if (a > 0) {
        if (b > 0) {
            result = a + b;
        } else {
            result = a - c;
        }
    } else {
        if (c > 0) {
            result = b * c;
        } else {
            result = a + b + c;
        }
    }
    return result;
}
```

1. a = 5, b = 3, c = 2（全真）
2. a = 5, b = -3, c = 2（条件1为真，条件2为假，条件3为真）
3. a = -5, b = 3, c = 2（条件1为假，条件2、3为真）
4. a = 5，b = 3,c = -2 (条件3为假，条件1、2为真)
5. a = -5, b = -3, c = 2（条件1、2为假，条件3为真）
6. a = -5, b = 3, c = -2（条件1、3为假，条件2为真）
7. a = 5, b = -3, c = -2  (条件2、3为假，条件1为真）
8. a = -5, b = -3, c = -2（条件1、2、3为假）

【5】路径覆盖：程序中的所有路径都必须经过一次，如果有环，环也至少一次。

1. a > 0, b > 0
2. a > 0, b <= 0, c > 0
3. a <= 0, c > 0
4. a <= 0, c <= 0

#### 数据流测试

**(有点难理解，我觉得不会考)**

- **定义**

  数据流测试根据**变量**的定义和使用情况来进行的路径测试

  | 概念            | 定义                                                         |
  | --------------- | ------------------------------------------------------------ |
  | 变量的定义(def) | 如果语句n对变量v的值进行了修改，则称n为变量v的定义语句，记做DEF(,n)          例如 int a = 0 ; |
  | 变量的使用(use) | 如果语句n对变量v的值进行了访问，则称n为变量v的使用语句，记做USE(v,n) |
  | 谓词使用        | 如果对变量的访问出现在谓词中，则成为谓词使用（变量作为判定条件） |
  | 计算使用        | 如果对变量的访问出现在计算中，则成为计算使用                 |
  | 定义-使用路径   | 如果程序(图)中存在一条路径p，对某个变量v，p的起点m为DEF(v,m)，p的终点n为USE(v,n)，则称p为关于v的定义-使用路径 |
  | 定义-清除路径   | 如果程序(图)中的一条路径p是关于变量v的定义-使用路径，且p中除了起点外，不存其它关于v的定义语句(定义节点)，则称p是关于变量v的定义-清除路径 |

- **覆盖指标**
  **设T是程序图G中的一个路径集合，V表示程序中的所有变量**

  | 指标   | 解释                                                         |
  | ------ | ------------------------------------------------------------ |
  | 全定义 | 对于任意v∈V，如果T包含从v的所有定义节点到v的一个使用节点的定义清除路径(不要求覆盖所有v的使用节点) |
  | 全使用 | 对于任意v€V，如果T包含从v的所有定义节点到v的所有使用节点的定义清除路径 |

  注意：不是求v的所有定义节点到v的所有使用节点的卡尔积，因为有些路径是不可实现的

  | 指标                    | 解释                                                         |
  | ----------------------- | ------------------------------------------------------------ |
  | 全计算使用-部分谓词使用 | 对于任意v∈V，如果T包含从v的所有定义节点到v的所有计算使用节点的定义清除路径(若v的一个定义没有计算使用，那么T至少包含一条到v的谓词使用的定义清除路径 |
  | 全谓词使用-部分计算使用 | 对于任意v∈V，如果T包含从v的所有定义节点到v的所有谓词使用节点的定义清除路径(若v的一个定义没有谓词使用，那么T至少包含一条到v的计算使用的定义清除路径 |

  **例题：**

```c++
1 void f(int x,int y,int m){
2	w=x;
3	if(m>0)
4		w++;
5	else
6		w=w+2;
7	if(y<=10)
8		x=5*y;
9	else
10		x=3*y+5;
11	z=w+x;
	}
```

图中每个圆圈代表代码的每一行

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/30.png" style="zoom: 67%;" />  

步骤一、

![截图 2024-05-11 20-48-37](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/截图 2024-05-11 20-48-37.png) 

> du-path和dc-path 都是对于变量来讲的，比如y 的du-path是某某，y 的dc-path是某某。
>
> 面对程序我们把每一个变量当作一个片 来考虑，但是对于整个程序我们综合所有变量的dc-path来给出测试路径和测试用例

步骤二、

**全定义覆盖准则：**

测试路径1：1→2→3→4→7→8→11

测试路径2：1→2→3→6→7→10→11

|           | 输入数据     | 预期输出               |
| --------- | ------------ | ---------------------- |
| 测试用例1 | x=0 y=0 m=1  | x=0 y=0 m=1 w=1 z=1    |
| 测试用例2 | x=0 y=11 m=0 | x=38 y=11 m=0 w=2 z=40 |

**全使用覆盖准则：**

测试路径1：1→2→3→4→7→8→11

测试路径2：1→2→3→6→7→10→11

|           | 输入数据     | 预期输出               |
| --------- | ------------ | ---------------------- |
| 测试用例1 | x=0 y=0 m=1  | x=0 y=0 m=1 w=1 z=1    |
| 测试用例2 | x=0 y=11 m=0 | x=38 y=11 m=0 w=2 z=40 |

**全定义-使用路径覆盖准则：**

测试路径1：1→2→3→4→7→8→11

测试路径2：1→2→3→6→7→10→11

测试路径3：1→2→3→6→7→8→11

测试路径4：1→2→3→4→7→10→11

|           | 输入数据     | 预期输出               |
| --------- | ------------ | ---------------------- |
| 测试用例1 | x=0 y=0 m=1  | x=0 y=0 m=1 w=1 z=1    |
| 测试用例2 | x=0 y=11 m=0 | x=38 y=11 m=0 w=2 z=40 |
| 测试用例3 | x=0 y=0 m=0  | x=0 y=0 m=0 w=2 z=2    |
| 测试用例4 | x=0 y=11 m=1 | x=38 y=11 m=1 w=1 z=39 |

### 三、黑盒测试

#### 等价测试：

对于不同的输入触发相似的程序，将这两个测试用例归为等价，在测试的时候只需要选择一个就可以了

【有效等价类】：等价类中的值都是有效输入，而且对于测试效果相同

【无效等价类】：等价类中的值都是无效输入，而且他们对测试的效果相同

**X1有三个等价类[a,b]、(b,c]、(c,d]，X2有两个等价类[e,f)、[f,g]**

1） 弱一般等价类测试：从变量的每个等价类中选择一个值即可，3个。（选择不唯一，下同）

![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/3.png) 

2）强一般等价类测试：从笛卡尔积结果中每个元素取一个值，6个

 ![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/4.png)

3）弱健壮等价类测试：对于有效输入，使用每个有效类的一个值（同  弱一般等价类测试）；对于无效输入，测试用例取一个无效值，其余的值都是有效的。x1<a,x1>d,x2<e,x2>g四个无效情况，无效输入的取值有四个，并保持其余有效。7个。

![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/5.png) 

4）强健壮等价类测试：有效类+无效类的笛卡尔乘积，从每个元素中获得测试用例

![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/6.png) 

结果 = 划分区域个数 * 划分区域个数 = 4 \* 4 = 16

例题：

假设你正在测试一个在线购物网站的“添加商品到购物车”功能。该功能的输入参数为：   
- 商品ID，其中商品可以是任意正在售卖的物品，比如牙膏、铅笔；   
- 数量，最高99
- 可用于特定商品品类型的折扣券ID，比如“文具类折扣券”、“书籍折扣券”。    
该功能的输出结果为购物车更新后的结果。   请编写符合强健壮性等价类测试的测试用例集合。

答：

这里为了简单描述将每一项的**所有有效类和无效类均归为一类，实际情况一般都有多个有效类和无效类**，这里例题只是为了帮助理解概念

有效输入测试用例：
\- 商品ID：牙膏、铅笔										
\- 数量  :  N∈[1，99] && n 为整数					
\- 折扣券ID：{文具类折扣券、书籍折扣券}		
无效输入测试用例：
\- 商品ID：不存在的商品ID							
\- 数量：N !∈[1,99] || 1到99的小数值			
\- 折扣券ID：不存在的折扣券ID					

一共有2 * 2 \* 2 = 8 种

| 测试用例编号 | 商品ID | 数量  | 折扣劵ID     | 结果                 |
| ------------ | ------ | ----- | ------------ | -------------------- |
| 1            | 牙膏   | 50    | 文具类折扣券 | 均符合要求           |
| 2            | 香蕉   | 50    | 书籍折扣券   | 商品ID不符           |
| 3            | 铅笔   | 0     | 文具类折扣券 | 数量不符             |
| 4            | 牙膏   | 50    | 香蕉类折扣劵 | 折扣劵不符           |
| 5            | 香蕉   | -10   | 文具类折扣券 | 商品ID和数量不符     |
| 6            | 香蕉5  | 15    | 香蕉类折扣劵 | 商品ID和折扣劵ID不符 |
| 7            | 牙膏   | 100   | 香蕉类折扣劵 | 数量和折扣劵ID不符   |
| 8            | 香蕉   | 37.46 | 香蕉类折扣劵 | 三项均不符           |

#### **边界值分析**

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/36.png" alt="img" style="zoom:67%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/37.png" style="zoom:67%;" />  

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/38.png" alt="img" style="zoom: 67%;" /> 

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/39.png" alt="img" style="zoom:67%;" /> 

#### 基于模型的测试

(老师ppt写的太抽象了，看不懂)

- **应用场景**
  在系统测试阶段，待测程序(即整个系统)过于复杂，以至于无法利用之前介绍的技术进行测试，这时可以使用基于模型的测试技术
- **基本思想**
  - 构造待测系统的模型(可以是分析、设计模型等)-------核心点是连接分析/设计和测试阶段
  - 根据系统模型产生测试用例
  - 如果模型刻画了系统的(部分)行为，则可以此作为测试断言

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/41.png" style="zoom: 80%;" /> 

#### 四、测试的策略

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/42.png"  /> 

## 第七章、项目维护与演化

1. 理解软件维护，包括软件维护的类型和主要任务
2. 了解软件重构、怀味道的概念
3. 了解技术债的含义

### 一、软件维护

- **定义**
  - 在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。
- 类型

  - 改正性维护：
    把诊断和改正错误的过程称为改正性维护
  - 适应性维护：
    为了和变化了的环境适当地配合而进行的修改软件的活动，是既必要又经常的维护活动
  - 完善性维护：
    在使用软件的过程中用户往往提出增加新功能或修改已有功能的建议，还可能提出一般性的改进意见，为满足用户新需求而修改软件的过程
  - 预防性维护：
    通过重构软件的文档、代码和数据从而提高软件的质量以应对将来可能发生的变化

### 二、软件重构

- 定义：在不改变软件行为的情况下，修改软件结构以提高软件的质量
- 常见形式
  - 代码重构
  - 模型重构
  - 文档重构

- 重构的目标

  - 代码不好的设计(怀味道）

    注：怀味道是一种隐喻，用来指那些(通常功能正常)结构、风格、设计不够优美的代码

- 重构的时机

  - 添加新功能时：重改代码以便使代码设计更加优越从而便于添加新功能
  - 修改错误时：重构代码以便更加容易发现错误
  - 代码审查时：提高代码可理解性

### 三、技术债

- 概念
  - 技术债是一种隐喻，比喻那些不会影响软件功能但会影响软件质量(特别是可维护性)的不成熟的制品
  - 技术债通常是软件开发过程中的短期捷径，但会对长期维护造成负面影响
  - 技术债是开发效率和质量之间的权衡
  - 技术债为成本管理提供了一种手段
- 技术债举例
  - 采用冒泡排序而不是归并排序实现成绩排序功能
  - 单元测试仅仅达到了语句覆盖而非路径覆盖
  - 已知软件存在未修复的错误
  - 文档编写不全
  - 采用新的、但是不成熟的编程语言开发软件
  - 采用市面上唯一的、但是beta版本的库开发软件
- 技术债的特点
  - 引入技术债在短期内会获得利益
  - 但长期看需要不断支付利息
  - 不彻底偿还技术债(修复软件)就不会消除技术债

- 债务的引入和偿还时机

  <img src="file:///media/kobayashi/%E6%96%B0%E5%8A%A0%E5%8D%B7/myblog/typora-user-images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/34.png" style="zoom: 80%;" /> 

  <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/35.png" style="zoom:80%;" /> 

- 度量：通常利用code smells作为债务的指示器
- 偿还：软件重构

## 第八章、项目管理

### 估算

#### **基于代码行数的估算**

根据多个开发人员的经验，对待开发系统(模块)的代码行数进行估计，计算加权平均

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/43.png" alt="截图 2024-05-11 21-26-00" style="zoom: 80%;" /> 

**举例：**

|       | min  | likely | max  |
| ----- | ---- | ------ | ---- |
| 人员1 | 2300 | 3000   | 3500 |
| 人员2 | 2800 | 3400   | 4000 |
| 人员3 | 2000 | 3200   | 4300 |

估计：3183

**缺点**

- 源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模似乎不太合理

- 用不同语言实现同一个软件所需要的代码行数并不相同
- 不适用于非命令式/过程式语言

#### **基于功能点的估算**

基于软件信息域的特征和技术复杂性的经验关系来计算功能点

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/44.png"  /> 

- **信息域特征(I)**

  - **外部输入数(EI):**每个外部输入源于一个用户，或从另一个应用系统中传送过来。它提供了面向应用系统的数据和控制信息。输入常用于更新内部逻辑文件。输入应与独立计数的查询(EQ)相区分开来。
  - **外部输出数(EO):**每个外部输出应从应系统中导出，并为用户提供信息。外部输出指的是报告、屏幕、错误消息等，不对报告中的单独数据项进行分开计数。
  - **外部查询数(EQ)：**一个外部查询定义为一个在线输入。其结果是以在线输出的方式产生的某个即时软件响应
  - **内部逻辑文件数(ILF):**每个内部逻辑文件是系统中内的数据逻辑分组，可能是一个数据库或者一个独立文件
  - **外部接口文件数(EIF):**每个外部接口文件是系统外部的数据逻辑分组，包括与外系统的接口

  举例如下：

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/45.png" style="zoom:80%;" /> 

 <img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/46.png" style="zoom:80%;" /> 

假设技术复杂性的值是46(题目给定的)，根据公式，对于50个信息域特征值的系统，具有的功能点是:
50 * ( 0.65 + 0.01 * 46 ) = 51.11

#### 工作量估计

工作量单位:人月，人年等
基本方法
获得规模估计值后，根据经验公式计算工作量

例如:
规模是2000行代码，人均生产力是2500行/月，则工作量是0.8人月

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/48.png" style="zoom:80%;" /> 

COCOMO2模型

![](/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/49.png) 

a,b是常数，fi是成本因素

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/50.png" style="zoom: 80%;" /> 

#### 开发时间估计

<img src="/media/kobayashi/新加卷/myblog/typora-user-images/软件工程/51.png" style="zoom:80%;" /> 
